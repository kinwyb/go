package db

import (
	"database/sql"
	"errors"
	"github.com/sirupsen/logrus"

	"github.com/gogo/protobuf/proto"
)

type ExecResult interface {
	sql.Result
	// 出错时回调参数方法
	Error(func(error)) ExecResult
	// 错误保存到日志
	ErrorToLog(log *logrus.Entry, msg ...string) ExecResult
	//是否出错
	HasError(reportZeroChange ...bool) error
}

//获取一个操作结果对象
func NewExecResult(rs sql.Result) ExecResult {
	return &rus{
		err:    nil,
		Result: rs,
	}
}

//查询错误结果
func ErrExecResult(err error, sql string, args []interface{}) ExecResult {
	return &rus{
		sql:  sql,
		args: args,
		err:  err,
	}
}

type rus struct {
	sql.Result
	sql  string
	args []interface{}
	err  error //查询错误
}

func (r *rus) Error(f func(err error)) ExecResult {
	if r.err != nil && f != nil {
		f(r.err)
	}
	return r
}

func (r *rus) ErrorToLog(log *logrus.Entry, msg ...string) ExecResult {
	if r.err != nil && log != nil {
		lg := log.WithField("sql", r.sql).
			WithField("req", r.args).
			WithError(r.err)
		if len(msg) > 0 {
			var msgs = []interface{}{"SQL错误:"}
			for _, v := range msg {
				msgs = append(msgs, v)
			}
			lg.Error(msgs...)
		} else {
			lg.Error("SQL错误")
		}
	}
	return r
}

func (r *rus) HasError(reportZeroChange ...bool) error {
	if r.err != nil {
		return r.err
	} else if len(reportZeroChange) < 1 {
		reportZeroChange = []bool{false}
	}
	changrow, _ := r.RowsAffected()
	if changrow == 0 && reportZeroChange[0] {
		return SQLEmptyChange
	}
	return nil
}

type rusMsg struct {
	lastInsertId int64
	rowsAffected int64
	err          error //查询错误
}

func (r *rusMsg) LastInsertId() (int64, error) {
	return r.lastInsertId, nil
}

func (r *rusMsg) RowsAffected() (int64, error) {
	return r.rowsAffected, nil
}

func (r *rusMsg) Error(f func(err error)) ExecResult {
	if r.err != nil && f != nil {
		f(r.err)
	}
	return r
}

func (r *rusMsg) ErrorToLog(log *logrus.Entry, msg ...string) ExecResult {
	if r.err != nil && log != nil {
		lg := log.WithError(r.err)
		if len(msg) > 0 {
			var msgs = []interface{}{"SQL错误:"}
			for _, v := range msg {
				msgs = append(msgs, v)
			}
			lg.Error(msgs...)
		} else {
			lg.Error("SQL错误")
		}
	}
	return r
}

func (r *rusMsg) HasError(reportZeroChange ...bool) error {
	if r.err != nil {
		return r.err
	} else if len(reportZeroChange) < 1 {
		reportZeroChange = []bool{false}
	}
	changrow, _ := r.RowsAffected()
	if changrow == 0 && reportZeroChange[0] {
		return SQLEmptyChange
	}
	return nil
}

// LastInsertId returns the integer generated by the database
// in response to a command. Typically this will be from an
// "auto increment" column when inserting a new row. Not all
// databases support this feature, and the syntax of such
// statements varies.
func (r *rus) LastInsertId() (int64, error) {
	if r.Result != nil {
		return r.Result.LastInsertId()
	}
	return 0, r.err
}

// RowsAffected returns the number of rows affected by an
// update, insert, or delete. Not every database or database
// driver may support this.
func (r *rus) RowsAffected() (int64, error) {
	if r.Result != nil {
		return r.Result.RowsAffected()
	}
	return 0, r.err
}

func ExecResultToBytes(v ExecResult) []byte {
	msg := &ExecResultMsg{}
	l, err := v.LastInsertId()
	if err != nil {
		msg.ErrMsg = err.Error()
		msg.ErrCode = -1
	}
	msg.LastInsertId = l
	r, err := v.RowsAffected()
	if err != nil {
		msg.ErrMsg = err.Error()
		msg.ErrCode = -1
	}
	msg.RowsAffected = r
	e := v.HasError(true)
	if e != nil {
		msg.ErrCode = -1
		msg.ErrMsg = e.Error()
	}
	ret, _ := proto.Marshal(msg)
	return ret
}

func BytesToExecResult(v []byte) ExecResult {
	msg := &ExecResultMsg{}
	proto.Unmarshal(v, msg)
	ret := &rusMsg{
		lastInsertId: msg.LastInsertId,
		rowsAffected: msg.RowsAffected,
	}
	if msg.ErrMsg != "" {
		ret.err = errors.New(msg.ErrMsg)
	}
	return ret
}
